#!/usr/bin/env ruby
# The MIT License (MIT)
# Copyright (c) 2016 Christian Parpart (DaWanda GmbH) <christian@dawanda.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

require 'rubygems'
require 'em-eventsource'
require 'net/http'
require 'fileutils'
require 'logger'
require 'json'

# The label name that is identifying group filters.
# The value will be a comma seperated list of groups.
FILTER_GROUP_NAME = 'lb-group'
LB_PROXY_PROTOCOL = 'lb-proxy-protocol'
LB_VHOST = 'lb-vhost'

LB_SERVICE_PORT = 'lb-service-port'

# {{{ app instance health check
class HealthCheck
  attr_accessor :protocol, :interval, :http_path

  def initialize(protocol, interval, http_path)
    @protocol = protocol # http, tcp, redis, redis-master, redis-slave, ...
    @interval = interval
    @http_path = http_path
  end
end
# }}}
class AppInstance # {{{
  attr_accessor :name, :host, :port

  def initialize(name, host, port)
    @name = name
    @host = host
    @port = port
  end
end
# }}}
class AppCluster # {{{
  attr_accessor :app_id, :service_port, :protocol, :health_check,
                :labels, :vhosts, :proxy_protocol, :instances

  def initialize(app_id, service_port, protocol, health_check, labels,
                 proxy_protocol, vhosts, instances)
    @app_id = app_id
    @service_port = service_port
    @protocol = protocol
    @health_check = health_check
    @labels = labels
    @proxy_protocol = proxy_protocol
    @vhosts = vhosts
    @instances = instances
  end

  def app_protocol
    if labels['proto']
      labels['proto']
    elsif health_check
      health_check.protocol
    else
      protocol
    end
  end
end
# }}}
class HaproxyBuilder # {{{
  attr_accessor :binpath, :cfgfile, :pidfile, :bindaddr, :logger

  def initialize(binpath, cfgfile, pidfile, bindaddr, port, logger)
    @binpath = binpath
    @cfgfile = cfgfile
    @pidfile = pidfile
    @bindaddr = bindaddr
    @port = port
    @logger = logger
  end

  def apply(clusters, force)
    tmpfile = "#{@cfgfile}.tmp"

    write_config(tmpfile, clusters)
    check_haproxy(tmpfile)

    if !File.exist?(@cfgfile) then
      logger.debug "File new. #{@cfgfile} reloaded."
      FileUtils.mv(tmpfile, @cfgfile)
      ensure_haproxy
    elsif !FileUtils.identical?(tmpfile, @cfgfile) then
      logger.debug "File changed. #{@cfgfile} reloaded."
      FileUtils.rm(@cfgfile)
      FileUtils.mv(tmpfile, @cfgfile)
      ensure_haproxy
    else
      logger.debug "Nothing changed. #{@cfgfile} not reloaded."
      FileUtils.rm(tmpfile)
      ensure_haproxy if force
    end
  rescue => bang
    logger.error "[haproxy] Failed to apply configuration. #{bang}"
  end

  def valid_pid?(pid)
    Process.kill(0, pid)
    # pid = Process.spawn(status_cmd)
    # Process.wait(pid)
    # pid, status = Process.waitpid2(pid)
    # status.exitstatus == 0
  rescue => bang
    logger.debug "Error while testing for valid PID #{pid}. #{bang}"
    false
  end

  def kill_process(pid)
    Process.kill(:SIGKILL, pid)
  rescue => bang
    logger.debug "Error while killing PID #{pid}. #{bang}"
  end

  def check_haproxy(cfgfile)
    args = [@binpath, '-f', cfgfile, '-p', @pidfile, '-c']
    logger.info "Checking haproxy configuration. #{args.join(' ')}"

    io = IO.popen(args.join(' '))
    output = io.read.strip
    io.close
    status = $?.exitstatus

    if !output.empty? then
      if status != 0 then
        logger.error "#{output}"
      else
        logger.info "#{output}"
      end
    end

    status
  end

  def start_haproxy
    args = [@binpath, '-f', @cfgfile, '-p', @pidfile, '-D', '-q']
    logger.info "Starting haproxy. #{args.join(' ')}"
    io = IO.popen(args.join(' '))
    output = io.read
    io.close
    logger.debug "start haproxy program output: #{output}" unless output.empty?
  end

  def reload_haproxy(pid)
    args = [@binpath, '-D', '-p', @pidfile, '-f', @cfgfile, '-sf', pid]
    logger.info "Reloading haproxy. #{args.join(' ')}"
    io = IO.popen(args.join(' '))
    output = io.read
    io.close
    logger.debug "reload haproxy program output: #{output}" unless output.empty?
  end

  def ensure_haproxy
    if File.exist?(@pidfile) then
      pid = File.read(@pidfile).strip.to_i
      if valid_pid?(pid) then
        reload_haproxy(pid)
      else
        logger.info "PID file #{@pidfile} contains an invalid PID #{pid}."
        kill_process(pid)
        start_haproxy
      end
    else
      start_haproxy
    end
  end

  def write_config_http(file, port)
    # TODO
    file.write "frontend http\n"
    file.write "  bind #{@bindaddr}:#{port}\n"
    file.write "  mode tcp\n"
    file.write "  tcp-request inspect-delay 5s\n"
    file.write "  tcp-request content accept if { req_ssl_hello_type 1 }\n"
    file.write "\n"

  end

  def write_config_https(file, port)
    file.write "frontend https\n"
    file.write "  bind #{@bindaddr}:#{port}\n"
    file.write "  mode tcp\n"
    file.write "  tcp-request inspect-delay 5s\n"
    file.write "  tcp-request content accept if { req_ssl_hello_type 1 }\n"
    file.write "\n"

    # TODO: SNI vhost selector
    file.write "  acl application_1 req_ssl_sni -i application1.domain.com\n"
    file.write "  acl application_2 req_ssl_sni -i application2.domain.com\n"
    file.write "\n"

    # TODO: declare vhost backends
    file.write "  use_backend bk_ssl_application_1 if application_1\n"
    file.write "  use_backend bk_ssl_application_2 if application_2\n"
    file.write "\n"

    file.write "  default_backend bk_ssl_default\n"
    file.write "\n"
  end

  def write_config(filename, clusters)
    logger.debug "HaproxyBuilder.write_config(\"#{filename}\")"
    file = File.open(filename, File::CREAT | File::TRUNC | File::WRONLY, 0644)

    file.write "global\n"
    file.write "  maxconn 32768\n"
    file.write "\n"

    file.write "defaults\n"
    file.write "  timeout client 90000\n"
    file.write "  timeout server 90000\n"
    file.write "  timeout connect 90000\n"
    file.write "  timeout queue 90000\n"
    file.write "  timeout http-request 90000\n"
    file.write "\n"

    write_config_https(file, 443)
    write_config_http(file, 80)

    if @port != 0 then
      file.write "listen haproxy\n"
      file.write "  bind #{@bindaddr}:#{@port}\n"
      file.write "  mode http\n"
      file.write "  stats enable\n"
      file.write "  stats uri /\n"
      file.write "  stats admin if TRUE\n"
      file.write "  monitor-uri /haproxy?monitor\n"
      file.write "\n"
    end

    clusters.each do |app_id, cluster|
      # skip if the transport layer is anything else then TCP (e.g. UDP)
      next unless cluster.protocol == 'tcp'

      # kill the first / and replace any other occurence with a dot
      app_id = app_id.slice(1, app_id.length - 1)
      app_id = app_id.gsub('/', '.')

      file.write "listen #{app_id}-#{cluster.service_port}\n"
      file.write "  bind #{@bindaddr}:#{cluster.service_port}\n"
      file.write "  balance leastconn\n"

      # health check interval defaults to 10s
      healthcheck_interval =
          if cluster.health_check && cluster.health_check.interval
            cluster.health_check.interval * 1000
          else
            10 * 1000
          end

      case cluster.app_protocol
      when 'http'
        file.write "  mode http\n"
        file.write "  option forwardfor\n"
        file.write "  option abortonclose\n"
        file.write "  option httpchk GET #{cluster.health_check.http_path || '/'}\n"
        # TODO support custom haproxy option fields
      when 'redis'
        file.write "  mode tcp\n"
        file.write "  option tcp-check\n"
        file.write "  tcp-check connect\n"
        file.write "  tcp-check send PING\\r\\n\n"
        file.write "  tcp-check expect string +PONG\n"
        file.write "  tcp-check send QUIT\\r\\n\n"
        file.write "  tcp-check expect string +OK\n"
      when 'redis-slave'
        file.write "  mode tcp\n"
        file.write "  option tcp-check\n"
        file.write "  tcp-check connect\n"
        file.write "  tcp-check send PING\\r\\n\n"
        file.write "  tcp-check expect string +PONG\n"
        file.write "  tcp-check send info\\ replication\\r\\n\n"
        file.write "  tcp-check expect string role:slave\n"
        file.write "  tcp-check send QUIT\\r\\n\n"
        file.write "  tcp-check expect string +OK\n"
      when 'redis-master'
        file.write "  mode tcp\n"
        file.write "  option tcp-check\n"
        file.write "  tcp-check connect\n"
        file.write "  tcp-check send PING\\r\\n\n"
        file.write "  tcp-check expect string +PONG\n"
        file.write "  tcp-check send info\\ replication\\r\\n\n"
        file.write "  tcp-check expect string role:master\n"
        file.write "  tcp-check send QUIT\\r\\n\n"
        file.write "  tcp-check expect string +OK\n"
      else
        # TODO support custom haproxy option fields
        file.write "  mode tcp\n"
      end

      server_opts = ""
      case cluster.proxy_protocol
        when 1 server_opts = "#{server_opts} send-proxy"
        when 2 server_opts = "#{server_opts} send-proxy-v2"
      end

      cluster.instances.each do |i|
        name = i.host.gsub(`domainname`.strip, '').gsub(/\.$/, '') + ":" + i.port.to_s
        file.write "  server #{name} #{i.host}:#{i.port}" +
                   " #{server_opts}" +
                   " check inter #{healthcheck_interval}" +
                   "\n"
      end
      file.write "\n"
    end
    file.close
  end
end
# }}}
class UpstreamConfDirHandler # {{{
  attr_accessor :confd_path, :logger

  def initialize(confd_path, logger)
    @confd_path = confd_path
    @logger = logger

    FileUtils.mkdir_p(@confd_path)
  end

  def apply(clusters, force)
    old_files = collect_files
    new_files = []

    clusters.each do |app_id, cluster|
      # kill the first / and replace any other occurence with a dot
      app_id = app_id.slice(1, app_id.length - 1)
      app_id = app_id.gsub('/', '.')

      cfgfile = "#{confd_path}/#{app_id}.instances"
      tmpfile = "#{cfgfile}.tmp"

      write_file(tmpfile, app_id, cluster)
      new_files << cfgfile

      # only write this file if it changes content (to preserve mtime)
      if !File.exist?(cfgfile) then
        logger.debug "confd: new #{cfgfile}"
        FileUtils.mv(tmpfile, cfgfile)
      elsif !FileUtils.identical?(tmpfile, cfgfile) then
        logger.debug "confd: refresh #{cfgfile}"
        FileUtils.mv(tmpfile, cfgfile)
      else
        FileUtils.rm(tmpfile)
      end
    end

    superfluous_files = old_files - new_files
    if !superfluous_files.empty? then
      logger.debug "Removing superfluous files: #{superfluous_files.join(', ')}"
      FileUtils.rm_f(superfluous_files)
    end
  rescue => bang
    logger.error "[confd] Failed to apply configuration. #{bang}"
  end

  def write_file(filename, app_id, cluster)
    flags = File::CREAT | File::TRUNC | File::WRONLY
    mode = 0644

    File.open(filename, flags, mode) do |file|
      file.write "Service-Name: #{app_id}\r\n"
      file.write "Service-Port: #{cluster.service_port}\r\n"
      file.write "Service-Transport-Proto: #{cluster.protocol}\r\n"
      file.write "Service-Application-Proto: #{cluster.app_protocol}\r\n"
      if cluster.health_check != nil then
        file.write "Health-Check-Proto: #{cluster.health_check.protocol}\r\n"
      end
      file.write "\r\n"
      cluster.instances.each do |instance|
        file.write "#{instance.host}:#{instance.port}\r\n"
      end
    end
  end

  def collect_files
    Dir.entries(@confd_path).reject {|f| f == '.' || f == '..' }.
                             map{|f| "#{@confd_path}/#{f}"}
  end
end # }}}
class MarathonServiceDiscovery # {{{
  def initialize(marathon_host, marathon_port, group_filter, handlers, logger)
    @marathon_host = marathon_host
    @marathon_port = marathon_port
    @group_filter = group_filter
    @logger = logger
    @handlers = handlers

    logger.debug "mmsd groups: #{group_filter.inspect}"

    events_url = "http://#{marathon_host}:#{marathon_port}/v2/events"
    logger.info "Listening on URL #{events_url}"
    @source = EventMachine::EventSource.new(events_url)
  end

  def logger
    @logger
  end

  def run
    reset_from_tasks(true)

    EM.run do
      @source.error {|message| sse_error(message)}
      @source.on 'status_update_event' do |json| status_update_event(json) end
      @source.on 'health_status_changed_event' do |json| health_status_changed_event(json) end
      @source.on 'deployment_success' do |json| deployment_success(json) end

      @source.start
    end
  end

  def sse_error(message)
    logger.error "SSE stream error. #{message}"
  end

  def status_update_event(json)
    logger.debug "on[status_update_event]:"
    obj = JSON.parse(json)

    slave_id = obj['slaveId']
    task_status = obj['taskStatus']
    message = obj['message']
    app_id = obj['appId']
    host = obj['host']
    port = obj['ports'][0]
    timestamp = obj['timestamp']

    if task_status == 'TASK_RUNNING' then
      logger.debug "[#{app_id}] new instance on #{host}:#{port}"
    else
      logger.debug "[#{app_id}] instance on #{host}:#{port} is #{task_status}"
    end

    reset_from_tasks
  end

  def health_status_changed_event(json)
    logger.debug "on[health_status_changed_event]:"
    reset_from_tasks
  end

  def deployment_success(json)
    logger.debug "on[deployment_success]:"
    reset_from_tasks
  end

private

  def reset_from_tasks(force = false)
    clusters = collect_clusters

    @handlers.each {|handler| handler.apply(clusters, force)}
  end

  # retrieves the number of services in a Marathon App
  def get_service_count(app)
    app['ports'].count
  end

  # Retrieves the service port number of a Marathon App at given port index.
  def get_service_port(app, index)
    app['ports'][index]
  end

  def get_service_protocol(app, index)
    protocols = (app['container']['docker']['portMappings'] || {}).map do |mapping|
      mapping['protocol']
    end

    protocols[index] || 'tcp'
  end

  def get_health_check(app, index)
    checks = app['healthChecks']
    return nil unless checks != nil

    check = checks[index]
    return nil unless check != nil

    case check['protocol']
    when 'HTTP'
      HealthCheck.new('http', check['intervalSeconds'].to_i, check['path'])
    when 'TCP'
      HealthCheck.new('tcp', check['intervalSeconds'].to_i, nil)
    else
      HealthCheck.new('tcp', nil, nil)
    end
  end

  # TODO: return array instead of map (not needed)
  def collect_clusters
    clusters = {}

    uri = "http://#{@marathon_host}:#{@marathon_port}/v2/apps?embed=apps.tasks"
    response = Net::HTTP.get(URI(uri))
    obj = JSON.parse(response)

    apps = obj['apps']
    apps.each do |app|
      app_id = app['id'].gsub('/', '.')

      service_ports = ((app['labels'] || {})[LB_SERVICE_PORT] || '').split(',')
      groups = ((app['labels'] || {})[FILTER_GROUP_NAME] || '').split(',')
      proxy_protocol = ((app['labels'] || {})[LB_PROXY_PROTOCOL] || '')
      vhosts = ((app['labels'] || {})[LB_VHOST] || '').split(',')

      if should_include?(app_id, groups) then
        get_service_count(app).times do |port_index|
          service_port = get_service_port(app, port_index)

          # override service_port in case lb-service-port label was provided
          if !service_ports.empty? && service_ports[port_index] != 0 then
            service_port = service_port[port_index]
          end

          app_service_name = "#{app_id}-#{port_index}"

          instances = []
          app['tasks'].each do |task|
            instances << AppInstance.new(task['id'],
                                         task['host'],
                                         task['ports'][port_index])
          end

          clusters[app_service_name] = AppCluster.new(
              app_service_name,
              service_port,
              get_service_protocol(app, port_index),
              get_health_check(app, port_index),
              app['labels'],
              vhosts,
              proxy_protocol,
              instances)
        end
      end
    end

    clusters
  end

  # filter applications by (globbed) group names
  # [production, staging1, staging2] & [staging*] == [staging1, staging2]
  def should_include?(app_id, groups)
    return true if @group_filter.include?('*')

    !groups.select do |group|
      @group_filter.any?{|g| File.fnmatch(g, group)}
    end.empty?
  end

  def dump_clusters(clusters)
    clusters.each do |app_id, cluster|
      puts "* #{cluster.app_id} #{cluster.service_port}"
      cluster.instances.each do |i|
        puts "  + #{i.host}:#{i.port}"
      end
    end
  end
end
# }}}
class Mmsd # {{{
  attr_accessor :logger

  def self.run(argv)
    mmsd = Mmsd.new(argv)
    mmsd.main
  end

  OPT_DEFAULTS = {'marathon-host' => '',
                  'marathon-port' => '',
                  'filter-groups' => '*',
                  'haproxy-bin' => '/usr/sbin/haproxy',
                  'haproxy-pidfile' => '/var/run/haproxy.pid',
                  'haproxy-cfg' => '/var/run/haproxy.cfg',
                  'haproxy-bind' => '0.0.0.0',
                  'haproxy-port' => '8081',
                  'enable-http' => '',
                  'enable-https' => '',
                  'upstream-confd' => '/var/run/mmsd/confd',
                  'log-level' => 'info'}

  def initialize(argv)
    @logger = Logger.new(STDOUT)

    @args = read_env(OPT_DEFAULTS)
    parse_args(argv, @args)
  end

  def read_env(defaults)
    opts = {}

    defaults.each do |name, default_value|
      env_name = name.gsub('-', '_').upcase
      env_value = ENV[env_name]

      opts[name] = env_value || default_value
    end

    opts
  end

  def parse_args(argv, opts)
    argv.each do |arg|
      name, value = arg.split('=')
      name.gsub!(/^--/, '')
      opts[name] = value
    end
  end

  def to_loglevel(value)
    case value
    when 'debug'
      Logger::DEBUG
    when 'info'
      Logger::INFO
    when 'warn'
      Logger::WARN
    when 'error'
      Logger::ERROR
    else
      Logger::ERROR
    end
  end

  def quick_shutdown(signo)
    # FIXME: why is logging from trap context prohibited but puts allowed?
    puts "Quick Shutdown (#{signo})."
    exit 0
  end

  def main
    $stdout.sync = true

    logger.level = to_loglevel(getopt('log-level'))

    Signal.trap(:SIGINT) {|num| quick_shutdown(num)}
    Signal.trap(:SIGQUIT) {|num| quick_shutdown(num)}
    Signal.trap(:SIGTERM) {|num| quick_shutdown(num)}

    handlers = []
    handlers << UpstreamConfDirHandler.new(getopt('upstream-confd'), logger)
    handlers << HaproxyBuilder.new(getopt('haproxy-bin'),
                                   getopt('haproxy-cfg'),
                                   getopt('haproxy-pidfile'),
                                   getopt('haproxy-bind'),
                                   getopt('haproxy-port').to_i,
                                   logger)

    sd = MarathonServiceDiscovery.new(getopt('marathon-host'),
                                      getopt('marathon-port').to_i,
                                      getopt('filter-groups').split(','),
                                      handlers,
                                      logger)
    sd.run
  end

  def getopt(name)
    @args[name] || ''
  end
end
# }}}

Mmsd.run(ARGV)
