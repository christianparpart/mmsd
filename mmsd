#!/usr/bin/env ruby
# coding: utf-8

require 'rubygems'
require 'em-eventsource'
require 'net/http'
require 'fileutils'
require 'logger'
require 'json'
require 'pp'
require 'open3'

# {{{ app instance health check
class HealthCheck
  def initialize
    @mode = :http # :http, :tcp, :redis_master, :redis_slave
    @http_uri = "/"
    @http_ignore_1xx = true
    @tcp_send = ""
    @tcp_expect = ""
  end
end
# }}}
class AppInstance # {{{
  attr_accessor :name, :host, :port

  def initialize(name, host, port)
    @name = name
    @host = host
    @port = port
  end
end
# }}}
class AppCluster # {{{
  attr_accessor :instances, :app_id, :service_port, :mode

  def initialize(app_id, service_port, mode)
    @instances = []
    @app_id = app_id
    @service_port = service_port
    @mode = mode
  end

  def add_backend(name, host, port)
    @instances << AppInstance.new(name, host, port)
  end
end
# }}}
class HaproxyBuilder # {{{
  def initialize(haproxy_bin, haproxy_cfg, haproxy_pidfile, logger)
    @binpath = haproxy_bin
    @cfgfile = haproxy_cfg
    @pidfile = haproxy_pidfile
    @logger = logger
  end

  def logger
    @logger
  end

  def apply(clusters)
    tmpfile = "#{@cfgfile}.tmp"
    write_config(tmpfile, clusters)
    if not File.exist?(@cfgfile) then
      logger.debug "File new. #{@cfgfile} reloaded."
      FileUtils.mv(tmpfile, @cfgfile)
      reload_haproxy
    elsif not FileUtils.identical?(tmpfile, @cfgfile) then
      logger.debug "File changed. #{@cfgfile} reloaded."
      FileUtils.rm(@cfgfile)
      FileUtils.mv(tmpfile, @cfgfile)
      reload_haproxy
    else
      logger.debug "Nothing changed. #{@cfgfile} not reloaded."
      FileUtils.rm(tmpfile)
      ensure_haproxy
    end
  end

  def reload_haproxy
    logger.debug "TODO: Reload or Restart haproxy"
    if File.exists?(@pidfile) then
      pid = File.read(@pidfile)
      logger.notice "PID: #{pid} from #{@pidfile}"

      logger.debug "reload haproxy"
      cin, cout, cerr = Open3::popen3(@binpath,
                                      '-f', @cfgfile,
                                      '-p', @pidfile,
                                      '-sf', pid,
                                      '-q')

      logger.debug "#{@haproxy_bin} stdout: #{cout.read}"
      logger.debug "#{@haproxy_bin} stderr: #{cerr.read}"
      sleep 2
      cin.close
      cout.close
      cerr.close
    else
      logger.debug "start haproxy #{@binpath}, #{@cfgfile}, #{@pidfile}"
      cin, cout, cerr = Open3::popen3(@binpath,
                                      '-f', @cfgfile,
                                      '-p', @pidfile,
                                      '-q')

      logger.debug "#{@haproxy_bin} stdout: #{cout.read}"
      logger.debug "#{@haproxy_bin} stderr: #{cerr.read}"
      sleep 2
      cin.close
      cout.close
      cerr.close
    end

    # TODO start or reload
  end

  def ensure_haproxy
    reload_haproxy
  end

  def write_config(filename, clusters)
    logger.debug "HaproxyBuilder.write_config(\"#{filename}\")"
    file = File.open(filename, File::CREAT | File::TRUNC | File::RDWR, 0644)

    file.write "global\n"
    file.write "  maxconn 32768\n"
    file.write "\n"

    file.write "defaults\n"
    file.write "  timeout client 90000\n"
    file.write "  timeout server 90000\n"
    file.write "  timeout connect 90000\n"
    file.write "  timeout queue 90000\n"
    file.write "  timeout http-request 90000\n"
    file.write "\n"

    file.write "listen haproxy *:8081\n"
    file.write "  mode http\n"
    file.write "  stats enable\n"
    file.write "  stats uri /\n"
    file.write "  stats admin if TRUE\n"
    file.write "  monitor-uri /haproxy?monitor\n"
    file.write "\n"

    clusters.each do |app_id, cluster|
      file.write "listen #{cluster.app_id} *:#{cluster.service_port}\n"
      file.write "  balance leastconn\n"

      healthcheck_http_uri = '/'    # TODO: load from marathon
      healthcheck_interval = 10000  # TODO: load from marathon

      if cluster.mode == 'http' then
        file.write "  mode http\n"
        file.write "  option forwardfor\n"
        file.write "  option abortonclose\n"
      else
        file.write "  mode tcp\n"
      end
      # TODO support custom haproxy option fields

      cluster.instances.each do |i|
        name = i.host.gsub(`domainname`.strip, '').gsub(/\.$/, '') + ":" + i.port.to_s
        file.write "  server #{name} #{i.host}:#{i.port}" +
                   " check inter #{healthcheck_interval}" +
                   "\n"
      end
      file.write "\n"
    end
    file.close
  end
end
# }}}
class MarathonServiceDiscovery # {{{
  def initialize(marathon_host, marathon_port, groups, lb, logger)
    @marathon_host = marathon_host
    @marathon_port = marathon_port
    @groups = groups
    @lb = lb
    @logger = logger

    events_url = "http://#{marathon_host}:#{marathon_port}/v2/events"
    logger.info "Listening on URL #{events_url}"
    @source = EventMachine::EventSource.new(events_url)
  end

  def logger
    @logger
  end

  def run
    reset_from_tasks

    EM.run do
      @source.error {|message| sse_error(message)}
      @source.on 'status_update_event' do |json| status_update_event(json) end
      @source.on 'health_status_changed_event' do |json| health_status_changed_event(json) end
      @source.on 'deployment_success' do |json| deployment_success(json) end

      @source.start
    end
  end

  def sse_error(message)
    logger.error "SSE stream error. #{message}"
  end

  def status_update_event(json)
    logger.debug "on[status_update_event]:"
    obj = JSON.parse(json)

    slave_id = obj['slaveId']
    task_status = obj['taskStatus']
    message = obj['message']
    app_id = obj['appId']
    host = obj['host']
    port = obj['ports'][0]
    timestamp = obj['timestamp']

    if task_status == 'TASK_RUNNING' then
      logger.debug "[#{app_id}] new instance on #{host}:#{port}"
    else
      logger.debug "[#{app_id}] instance on #{host}:#{port} is #{task_status}"
    end

    reset_from_tasks
  end

  def health_status_changed_event(json)
    logger.debug "on[health_status_changed_event]:"
    reset_from_tasks
  end

  def deployment_success(json)
    logger.debug "on[deployment_success]:"
    reset_from_tasks
  end

private

  def reset_from_tasks
    clusters = collect_clusters

    @lb.apply(clusters)
  end

  def collect_clusters
    clusters = {}

    uri = "http://#{@marathon_host}:#{@marathon_port}/v2/tasks?embed=tasks.apps"
    response = Net::HTTP.get(URI(uri))
    obj = JSON.parse(response)

    tasks = obj['tasks']
    tasks.each do |task|
      name = task['id']
      host = task['host']
      port = task['ports'][0]
      app_id = task['appId'].gsub('/', '.')
      service_port = task['servicePorts'][0] # XXX only the first one as primary

      if should_include?(app_id) then
        cluster = clusters[app_id]
        if cluster  == nil then
          mode = 'tcp' # TODO: one of (tcp, http, ...)
          cluster = clusters[app_id] = AppCluster.new(app_id, service_port, mode)
          # TODO: add health check definitions
        end
        cluster.add_backend(name, host, port)
      end
    end

    clusters
  end

  def should_include?(app_id)
    true # TODO: filter by @groups
  end

  def dump_clusters(clusters)
    clusters.each do |app_id, cluster|
      puts "* #{cluster.app_id} #{cluster.service_port}"
      cluster.instances.each do |i|
        puts "  + #{i.host}:#{i.port}"
      end
    end
  end
end
# }}}
class Mmsd # {{{
  def self.run(argv)
    mmsd = Mmsd.new(argv)
    mmsd.main
  end

  OPT_DEFAULTS = {'marathon-host' => '',
                  'marathon-port' => '',
                  'groups' => '*',
                  'haproxy-bin' => '/usr/sbin/haproxy',
                  'haproxy-pidfile' => '/var/run/haproxy.pid',
                  'haproxy-cfg' => '/var/run/haproxy.cfg',
                  'log-level' => 'info'}

  def initialize(argv)
    @args = read_env(OPT_DEFAULTS)
    parse_args(argv, @args)
  end

  def read_env(defaults)
    opts = {}

    defaults.each do |name, default_value|
      env_name = name.gsub('-', '_').upcase
      env_value = ENV[env_name]

      opts[name] = env_value || default_value
    end

    opts
  end

  def parse_args(argv, opts)
    argv.each do |arg|
      name, value = arg.split('=')
      name.gsub!(/^--/, '')
      opts[name] = value
    end
  end

  def to_loglevel(value)
    puts "to_loglevel: #{value}"
    case value
    when 'debug'
      Logger::DEBUG
    when 'info'
      Logger::INFO
    when 'warn'
      Logger::WARN
    when 'error'
      Logger::ERROR
    else
      Logger::ERROR
    end
  end

  def main
    $stdout.sync = true

    logger = Logger.new(STDOUT)
    logger.level = to_loglevel(getopt('log-level'))

    sd = MarathonServiceDiscovery.new(getopt('marathon-host'),
                                      getopt('marathon-port'),
                                      getopt('groups'),
                                      HaproxyBuilder.new(getopt('haproxy-bin'),
                                                         getopt('haproxy-cfg'),
                                                         getopt('haproxy-pidfile'),
                                                         logger),
                                      logger)
    sd.run
  end

  def getopt(name)
    puts "getopt[#{name}] = #{(@args[name] || '').inspect}"
    @args[name] || ''
  end
end
# }}}

Mmsd.run(ARGV)
